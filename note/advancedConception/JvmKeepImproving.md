# JVM 把細節做到了極致（偏向鎖、輕量級鎖、自旋鎖、鎖消除）

<br>

---

<br>

JDK 開發團隊真的把多執行緒優化設計到極致，其內部有幾種鎖優化策略這邊一定要介紹一下，真的是細緻入微。

<br>

## 偏向鎖

<br>

偏向鎖是一種針對加鎖優化手法，他的思想是：如果一個 Thread 獲得鎖，那這個鎖就進入偏向模式。當這個 Thread 再次請求鎖時，就不用再對鎖進行同步處理。這樣就節省了大量鎖申請同步操作的資源消耗。

在幾乎沒有鎖競爭的場合，偏向鎖有比交好的優化效果，因為連續多次極有可能是同一個 Thread 請求相同鎖。而對於競爭激烈的場合就不太好了。在競爭激烈場合幾乎都是不同 Thread 搶一把鎖，這樣偏向模式會失敗。

使用 JVM 參數啟動偏向鎖：

<br>

```java
java -XX:+UseBiasedLocking
```

<br><br>

## 輕量級鎖

<br>

若偏向鎖失敗，JVM 並不會馬上掛起 Thread 讓他等待，他會用一種輕量鎖優化手段。

他簡單的將物件頭部作為 pointer，指向持有鎖的 Thread 堆棧內部來判斷一個 Thread 是否持有物件鎖，如果 Thread 獲得輕量鎖成功，那就可以順利進入同步化。如果輕量鎖上鎖失敗，則表示其他 Thread 搶先搶到鎖了，那當前 Thread 的鎖請求直接膨脹成重量鎖。

<br><br>

## 自旋鎖

<br>

鎖膨脹後，JVM 為了避免 Thread 真的被無情掛起，於是他做了最後的努力，就是自旋鎖。

由於當前 Thread 暫時無法獲取鎖，但是可能在幾個 CPU 執行週期後就可以拿到鎖了，如果真是這樣，那叫這個 Thread 直接掛起等待就太浪費了，因此 JVM 進行一次賭博：我猜他會在不久後取得這把鎖。所以 JVM 會讓當前 Thread 做幾次空循環（原地自轉），經過幾次自旋後，如果真的得到鎖，那就順利繼續執行。如果還是失敗，那就真正把 Thread 掛起等待。

<br><br>

## 鎖消除

<br>

鎖消除是一種更徹底的優化。JVM 在 JIT 編譯時，透過對 Context 的掃瞄，去除不可能存在共享資源競爭的鎖。透過鎖消除，節省無意義的請求鎖時間。

不需要鎖，為何還要上鎖呢？這是因為在 JDK 中有一些 API，比如 __StringBuffer__、__Vector__ 等，它們內部實現使用了同步化（`synchronized`），如果我們寫了一個單 Thread 的程式，這種上鎖就毫無必要，進而會造成鎖請求浪費。

鎖消除涉及到一項技術：逃逸分析。逃逸分析會觀察一個變數是否會逃出某個區域。例如：

<br>

```java
public String[] createStrings() {
    Vector<String> v = new Vector<String>();
    for (int i = 0; i < 100; i++) {
        v.add(Integer.toString(i));
    }
    return v.toArray(new String[]{});
}
```

<br>

逃逸分析判斷變數 `v` 沒有逃出 `createStrings()` 方法之外，所以 JVM 可以大膽地將 v 內部的加鎖動作去掉。

如果 `createStrings()` 返回的是 `v` 本身，那逃逸分析會認為 `v` 逃出當前方法，所以 JVM 就不能消除 `v` 中的鎖操作。

__逃逸分析必須在 `-server` 模式下進行，可以使用 `-XX:+DoEscapeAnalysis` 參數打開逃逸分析，使用 `-XX:+EliminateLocks` 參數可以打開鎖消除。__