# 不一樣的併發思維策略：比較交換（CAS）

<br>

--------------------------------

<br>

併發鎖是一種悲觀策略，他總是覺得每一次多執行緒共同存取臨界區會發生衝突，因此每次操作都需要被嚴格管控，犧牲性能讓 Thread 等待，所以鎖會阻塞 Thread 執行。無鎖是一種樂觀策略，他總是認為 Thread 們可以在不用監管的情況下持續執行。遇到衝突時就使用交換比對技術（__CAS__ Compare And Swap）鑑定衝突。一旦鑑定到有衝突，就 retry 當前操作直到沒有衝突為止。

<br><br>

## CAS

<br>

__CAS__ 機制會比上鎖寫法複雜很多，但是他效能比上鎖高非常多，沒有鎖競爭帶來的系統資源開銷，也沒有 Thread 頻繁調度帶來的開銷，且不會再遇到死鎖問題，因為根本沒有鎖了。

<br>

__CAS__ 算法過程是這樣：他有 3 個參數 `CAS(V, E, N)`。`V` 表示要更新的變數， `E` 表示預期值，`N` 表示新值。只有當 `V` 值等於 `E` 值時，才會將 `V` 值設定成 `N`。如果 `V` 與 `N` 不同，則代表已經有其他 Thread 對此值做了改動，那麼當前 Thread 停止執行接下來任務，返回當前 `V` 值。失敗的 Thread 不會就這樣被掛起，他只是被告知失敗而已，他可以再次嘗試或者直接放棄。基於 __CAS__ 原理，既使不用鎖也可以發現 Thread 之間的衝突，並妥善處理。

簡單說，__CAS__ 就是修改前需要我們給出一個期望值 `E`，也就是我們認為這個變數現在應該是多少，如果檢查目前真正值 `V` 不是我們認為的 `E`，那就說明他已經被別人改過了，我們就要重新嘗試修改。

<br>

你可能會覺得，__CAS__ 先取出真實值 `V`，再與期望值 `E` 比較，最後用新值 `N` 取代真實值 `V`，這個過程難道不會被干擾嗎？其實底層處理器現在都已經支持原子化 __CAS__ 指令了
，JDK5 之後 JVM 就可以使用這個指令實現併發操作與併發資料結構。

<br>

__所以 __CAS__ 的比較將換就是一套原子化操作。__